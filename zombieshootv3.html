<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pixel Zombie Shooter - Aggressive Zombies</title>
<style>
  body {
    margin: 0;
    background: #0b0b0b;
    color: #eee;
    font-family: system-ui, Segoe UI, Roboto, Arial;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h2 {
    margin-top: 16px;
    margin-bottom: 8px;
  }
  #game-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 20px;
  }
  #canvas {
    background: #1a1a1a;
    image-rendering: pixelated;
    border: 4px solid #333;
    display: block;
  }
  #hud {
    margin-bottom: 12px;
    position: relative;
    height: 30px;
    text-align: center;
  }
  #hud span {
    margin: 0 8px;
    font-weight: bold;
  }
  button {
    background: #2b2b2b;
    color: #eee;
    border: 1px solid #444;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
  }
  #message {
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: bold;
    color: #ff4444;
    font-size: 18px;
    text-shadow: 0 0 6px #ff4444aa;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    white-space: nowrap;
  }
  #message.show {
    opacity: 1;
  }

  /* Start and Game Over overlays */
  #overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11,11,11,0.95);
    color: #eee;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 22px;
    z-index: 10;
  }
  #overlay.hidden {
    display: none;
  }
  #instructions {
    max-width: 300px;
    text-align: left;
    font-size: 14px;
    line-height: 1.4;
    background: #222;
    border: 2px solid #444;
    padding: 12px;
    border-radius: 8px;
    user-select: text;
    height: 480px; /* match canvas height */
    overflow-y: auto;
  }
</style>
</head>
<body>

<h2>Pixel Zombie Shooter - Aggressive Zombies</h2>

<div id="game-container">
  <div>
    <div id="hud">
      <span>Health: <strong id="health">100</strong></span>
      <span>Score: <strong id="score">0</strong></span>
      <span>Wave: <strong id="wave">1</strong></span>
      <button id="toggleSounds">Sounds: ON</button>
      <div id="message"></div>
    </div>
    <canvas id="canvas" width="640" height="480"></canvas>
  </div>

  <div id="instructions">
    <h3>Instructions</h3>
    <ul>
      <li>Move: <strong>W A S D</strong></li>
      <li>Aim: <strong>Mouse</strong></li>
      <li>Shoot: <strong>Click Mouse</strong></li>
      <li>Survive waves of zombies</li>
      <li>Each 10 kills increases wave and difficulty</li>
      <li>Every 25 kills zombies get faster</li>
      <li>Use the button above to toggle sounds</li>
    </ul>
  </div>
</div>

<!-- Overlay for Start and Game Over -->
<div id="overlay">
  <div id="start-screen">
    <h1>Pixel Zombie Shooter</h1>
    <p>Survive waves of aggressive zombies!</p>
    <button id="startButton">Start Game</button>
  </div>
  <div id="gameover-screen" style="display:none;">
    <h1>Game Over</h1>
    <p>Your final score: <span id="finalScore">0</span></p>
    <button id="restartButton">Restart Game</button>
  </div>
</div>

<script>
// --------- Config ---------
const CANVAS_W = 640, CANVAS_H = 480;
const PLAYER_SIZE = 32;
const ZOMBIE_SIZE = 32;
const GUN_SIZE = 28;
const SPAWN_DELAY = 1000;
const MAX_ZOMBIES_START = 4;
const PLAYER_SPEED = 2.6;
const BULLET_SPEED = 10;
const BULLET_LIFE = 240;
const DAMAGE = 20;
const MESSAGE_DURATION = 3000; // ms

// --------- Canvas setup ---------
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const healthEl = document.getElementById('health');
const scoreEl = document.getElementById('score');
const waveEl = document.getElementById('wave');
const toggleSoundsBtn = document.getElementById('toggleSounds');
const messageEl = document.getElementById('message');

const overlay = document.getElementById('overlay');
const startScreen = document.getElementById('start-screen');
const gameoverScreen = document.getElementById('gameover-screen');
const finalScoreEl = document.getElementById('finalScore');
const startButton = document.getElementById('startButton');
const restartButton = document.getElementById('restartButton');

let soundsEnabled = true;
toggleSoundsBtn.addEventListener('click', () => {
  soundsEnabled = !soundsEnabled;
  toggleSoundsBtn.textContent = 'Sounds: ' + (soundsEnabled ? 'ON' : 'OFF');
});

// --------- Audio ---------
const audioContext = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
function playBeep(freq=200, time=0.06, vol=0.1) {
  if(!soundsEnabled || !audioContext) return;
  const now = audioContext.currentTime;
  const o = audioContext.createOscillator();
  const g = audioContext.createGain();
  o.type = 'square';
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g);
  g.connect(audioContext.destination);
  o.start(now);
  g.gain.linearRampToValueAtTime(0.0, now + time);
  o.stop(now + time + 0.01);
}

// --------- Pixel-art sprite generator ---------
function makePixelCanvas(pixelMap, colorMap, scale) {
  const rows = pixelMap.length;
  const cols = Math.max(...pixelMap.map(r => r.length));
  const off = document.createElement('canvas');
  off.width = cols * scale;
  off.height = rows * scale;
  const oc = off.getContext('2d');
  oc.imageSmoothingEnabled = false;
  for (let y=0;y<rows;y++){
    for (let x=0;x<pixelMap[y].length;x++){
      const ch = pixelMap[y][x];
      if (ch === '.' || ch === ' ') continue;
      const color = colorMap[ch] || '#ff00ff';
      oc.fillStyle = color;
      oc.fillRect(x*scale, y*scale, scale, scale);
    }
  }
  return off;
}

function scaleSpriteFromMap(map, colors, outSize) {
  const rows = map.length;
  const cols = Math.max(...map.map(r => r.length));
  const baseScale = Math.floor(outSize / Math.max(rows, cols));
  const pxCanvas = makePixelCanvas(map, colors, baseScale);
  const final = document.createElement('canvas');
  final.width = outSize;
  final.height = outSize;
  const fctx = final.getContext('2d');
  fctx.imageSmoothingEnabled = false;
  const dx = Math.floor((outSize - pxCanvas.width)/2);
  const dy = Math.floor((outSize - pxCanvas.height)/2);
  fctx.drawImage(pxCanvas, dx, dy);
  return final;
}

// --------- Sprites ---------
const playerMap = [
  "......XX......",
  ".....XXXX.....",
  "....XXXXXX....",
  "...XX....XX...",
  "...X.XX..XX...",
  "...X.XX..XX...",
  "...XXXXXXXX...",
  "...XXXXXX.....",
  "..XXXX..XXXX..",
  "..XXX....XXX..",
  "..X..X..X..X..",
  ".X...X..X...X.",
  ".X...........X",
  "..X.........X.",
  "...X.......X..",
  "....X.....X..."
];
const playerColors = { 'X': '#00d2ff' };

const gunMap = [
  ".......G",
  "......GG",
  ".....GGG",
  "GGGGGGGG",
  "GGGGGGGG",
  ".....GGG",
  "......GG",
  ".......G"
];
const gunColors = { 'G': '#d9d29a' };

const zombieMap = [
  "..ZZZZZZZZ...",
  ".ZZZZZZZZZZ..",
  ".ZZ..ZZ..ZZ..",
  ".ZZ..ZZ..ZZ..",
  ".ZZZZZZZZZZ..",
  ".ZZZZZZZZZZ..",
  "..ZZZ..ZZZ...",
  "..ZZZ..ZZZ...",
  "..ZZZ..ZZZ...",
  ".ZZZ....ZZZ..",
  ".Z........Z..",
  ".Z..ZZZZ..Z..",
  ".Z..Z..Z..Z..",
  "..Z.....Z....",
  "...Z...Z.....",
  "....Z.Z......"
];
const zombieColors = { 'Z': '#5ac45a' };

const playerSprite = scaleSpriteFromMap(playerMap, playerColors, PLAYER_SIZE);
const zombieSprite = scaleSpriteFromMap(zombieMap, zombieColors, ZOMBIE_SIZE);
const gunSprite   = scaleSpriteFromMap(gunMap, gunColors, GUN_SIZE);

// --------- Entities ---------
class Entity {
  constructor(x,y){ this.x=x; this.y=y; }
  distTo(other){ const dx=this.x-other.x, dy=this.y-other.y; return Math.sqrt(dx*dx+dy*dy); }
}
class Player extends Entity {
  constructor(x,y){
    super(x,y);
    this.size = PLAYER_SIZE;
    this.health = 100;
    this.speed = PLAYER_SPEED;
  }
  drawAim(ctx, mouseX, mouseY) {
    const angle = Math.atan2(mouseY - this.y, mouseX - this.x);
    ctx.save();
    ctx.translate(this.x, this.y - 4);
    ctx.rotate(angle);
    ctx.drawImage(gunSprite, -GUN_SIZE/2, -GUN_SIZE/2, GUN_SIZE, GUN_SIZE);
    ctx.restore();
  }
  draw(ctx) {
    ctx.drawImage(playerSprite, this.x - this.size/2, this.y - this.size/2, this.size, this.size);
  }
}

class Bullet extends Entity {
  constructor(x,y,dx,dy){
    super(x,y);
    this.dx = dx; this.dy = dy;
    this.r = 3;
    this.life = BULLET_LIFE;
  }
  update(){
    this.x += this.dx; this.y += this.dy;
    this.life--;
  }
  draw(ctx){
    ctx.fillStyle = '#ffd86b';
    ctx.beginPath(); ctx.arc(Math.round(this.x), Math.round(this.y), this.r, 0, Math.PI*2); ctx.fill();
  }
}

class Zombie extends Entity {
  constructor(x,y,speed){
    super(x,y);
    this.speed = speed;
    this.size = ZOMBIE_SIZE;
    this.hp = 1;
  }
  updateTowards(player){
    const angle = Math.atan2(player.y - this.y, player.x - this.x);
    this.x += Math.cos(angle) * this.speed;
    this.y += Math.sin(angle) * this.speed;
  }
  draw(ctx){
    ctx.drawImage(zombieSprite, this.x - this.size/2, this.y - this.size/2, this.size, this.size);
  }
}

// --------- Game state ---------
const player = new Player(CANVAS_W/2, CANVAS_H/2);
const bullets = [];
const zombies = [];

let keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

let mouseX = player.x, mouseY = player.y;
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', e => {
  if(gameState === 'playing') shoot();
});

// --------- Shoot function ---------
function shoot() {
  const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
  const dx = Math.cos(angle) * BULLET_SPEED;
  const dy = Math.sin(angle) * BULLET_SPEED;
  const b = new Bullet(player.x + dx*1.5, player.y + dy*1.5, dx, dy);
  bullets.push(b);
  playBeep(600, 0.05, 0.15);
}

// --------- Spawn zombies ---------
let spawnTimer = 0;
let maxZombies = MAX_ZOMBIES_START;
let spawnInterval = SPAWN_DELAY;
let score = 0;
let wave = 1;

// Speed increase factor for zombies on every 25 kills
let aggroSpeedBonus = 0;

// For showing message
let messageTimeout = null;

function showMessage(text) {
  if(messageTimeout) clearTimeout(messageTimeout);
  messageEl.textContent = text;
  messageEl.classList.add('show');
  messageTimeout = setTimeout(() => {
    messageEl.classList.remove('show');
  }, MESSAGE_DURATION);
}

// --------- Game update ---------
function update() {
  if(gameState !== 'playing') return;

  // Player movement
  let moveX = 0, moveY = 0;
  if(keys['w']) moveY -= 1;
  if(keys['s']) moveY += 1;
  if(keys['a']) moveX -= 1;
  if(keys['d']) moveX += 1;
  if(moveX !== 0 || moveY !== 0){
    const len = Math.sqrt(moveX*moveX + moveY*moveY);
    moveX /= len; moveY /= len;
    player.x += moveX * player.speed;
    player.y += moveY * player.speed;
    // Keep player inside bounds
    player.x = Math.min(Math.max(player.size/2, player.x), CANVAS_W - player.size/2);
    player.y = Math.min(Math.max(player.size/2, player.y), CANVAS_H - player.size/2);
  }

  // Spawn zombies
  spawnTimer += 16.66; // approx frame time
  if(spawnTimer >= spawnInterval && zombies.length < maxZombies) {
    spawnTimer = 0;
    spawnZombie();
  }

  // Update bullets
  for(let i = bullets.length-1; i >=0; i--){
    const b = bullets[i];
    b.update();
    // Remove if out of bounds or life expired
    if(b.life <= 0 || b.x < 0 || b.x > CANVAS_W || b.y < 0 || b.y > CANVAS_H) {
      bullets.splice(i,1);
      continue;
    }
  }

  // Update zombies
  for(let i = zombies.length-1; i >=0; i--) {
    const z = zombies[i];
    z.updateTowards(player);

    // Check collision with player
    if(z.distTo(player) < (z.size + player.size)/2 - 8) {
      player.health -= 0.4;
      // Push zombie back a bit (knockback)
      const angle = Math.atan2(z.y - player.y, z.x - player.x);
      z.x += Math.cos(angle) * 4;
      z.y += Math.sin(angle) * 4;
      if(player.health <= 0) {
        endGame();
        return;
      }
    }

    // Check collision with bullets
    for(let j = bullets.length-1; j >= 0; j--) {
      const b = bullets[j];
      if(z.distTo(b) < (z.size/2 + b.r)) {
        // Hit zombie
        zombies.splice(i,1);
        bullets.splice(j,1);
        score++;
        playBeep(300, 0.1, 0.12);

        // Wave & difficulty scaling
        if(score % 10 === 0) {
          wave++;
          maxZombies = MAX_ZOMBIES_START + wave * 2;
          spawnInterval = Math.max(300, spawnInterval - 100);
          showMessage("Wave " + wave + "!");
          waveEl.textContent = wave;
          maxZombies = Math.min(maxZombies, 40);
        }
        if(score % 25 === 0) {
          aggroSpeedBonus += 0.2;
          showMessage("Zombies are getting faster!");
        }
        scoreEl.textContent = score;
        healthEl.textContent = Math.round(player.health);
        break;
      }
    }
  }
}

// Spawn zombies at random edge with speed increased by aggroSpeedBonus
function spawnZombie() {
  let x, y;
  const side = Math.floor(Math.random() * 4);
  switch(side) {
    case 0: x = Math.random() * CANVAS_W; y = -ZOMBIE_SIZE; break;
    case 1: x = Math.random() * CANVAS_W; y = CANVAS_H + ZOMBIE_SIZE; break;
    case 2: y = Math.random() * CANVAS_H; x = -ZOMBIE_SIZE; break;
    case 3: y = Math.random() * CANVAS_H; x = CANVAS_W + ZOMBIE_SIZE; break;
  }
  const baseSpeed = 0.7 + (wave * 0.1) + aggroSpeedBonus;
  const z = new Zombie(x,y, baseSpeed);
  zombies.push(z);
}

// --------- Game draw ---------
function draw() {
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

  // Draw player
  player.draw(ctx);
  player.drawAim(ctx, mouseX, mouseY);

  // Draw bullets
  bullets.forEach(b => b.draw(ctx));

  // Draw zombies
  zombies.forEach(z => z.draw(ctx));
}

// --------- Main loop ---------
let lastTime = 0;
function loop(t=0) {
  if(gameState === 'playing') {
    update();
    draw();
  }
  lastTime = t;
  requestAnimationFrame(loop);
}

// --------- Game states ---------
let gameState = 'start'; // start, playing, gameover

function startGame() {
  // Reset game state
  player.x = CANVAS_W/2;
  player.y = CANVAS_H/2;
  player.health = 100;
  bullets.length = 0;
  zombies.length = 0;
  score = 0;
  wave = 1;
  maxZombies = MAX_ZOMBIES_START;
  spawnInterval = SPAWN_DELAY;
  aggroSpeedBonus = 0;
  healthEl.textContent = player.health;
  scoreEl.textContent = score;
  waveEl.textContent = wave;
  overlay.classList.add('hidden');
  startScreen.style.display = 'block';
  gameoverScreen.style.display = 'none';
  messageEl.classList.remove('show');
  gameState = 'playing';
}

function endGame() {
  gameState = 'gameover';
  finalScoreEl.textContent = score;
  overlay.classList.remove('hidden');
  startScreen.style.display = 'none';
  gameoverScreen.style.display = 'block';
}

// --------- Buttons ---------
startButton.addEventListener('click', () => {
  startGame();
});
restartButton.addEventListener('click', () => {
  startGame();
});

// Start with overlay visible, waiting to start game
overlay.classList.remove('hidden');
startScreen.style.display = 'block';
gameoverScreen.style.display = 'none';

// Start the main loop
requestAnimationFrame(loop);

</script>

</body>
</html>
